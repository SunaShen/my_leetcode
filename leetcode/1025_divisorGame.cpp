// @File   : 1025_divisorGame.cpp
// @Source : https://leetcode-cn.com/problems/divisor-game/
// @Title  : 1025. 除数博弈
// @Auther : sun_ds
// @Date   : 2020/7/24

/**  题目描述：
    爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

    最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

    选出任一 x，满足 0 < x < N 且 N % x == 0 。
    用 N - x 替换黑板上的数字 N 。
    如果玩家无法执行这些操作，就会输掉游戏。

    只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

     

    示例 1：

    输入：2
    输出：true
    解释：爱丽丝选择 1，鲍勃无法进行操作。
    示例 2：

    输入：3
    输出：false
    解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
     

    提示：

    1 <= N <= 1000


    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/divisor-game
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/


/**
 *
 * 1.博弈论
 * 因为至少可以取1 ,所以最后决胜负的时候 就是谁取到1 就输了
 * 1.1拿到奇数时：只有一种选择就是减去奇数,给出偶数。 (奇数的因子只能是奇数)
 * 1.2拿到偶数的时候：有两种选择
 *    1.2.1.减去奇数返回奇数;
 *    1.2.2.减去偶数返回偶数;
 * 可见拿到偶数的人有能力选择保持另一个人奇偶性永远是奇数
 * 由于拿到1的人就输，所以偶数能一直保持另一个人是奇数, 且值一定不停的在减少趋向于1
 * 所以开始手里是偶数的人能赢。
 *
 * 2.递推
 * 设 f[i] 表示当前玩家先手的状态
 * f[i]==true 表示两个玩家都以最佳状态参与游戏，当前状态玩家必胜。
 * f[i]==false 表示两个玩家都以最佳状态参与游戏，当前状态玩家必输。
 *
 * 已知 f[1] = true,f[2] = false
 * 递推
 * 遍历可以取得值，只要满足 i%j==0，且 i-j 后的状态为必输，则当前状态为必胜。
 *
 * 最终返回 f[N] 为，数字为 N ，先手的结果。
 *
 *
 */

class Solution {
public:
    bool divisorGame(int N) {
        return N % 2 == 0;
    }
};


// 递推
class Solution {
public:
    bool divisorGame(int N) {
        vector<int> f(N + 2, false);

        f[1] = false;
        f[2] = true;
        for (int i = 3; i <= N; ++i) {
            for (int j = 1; j < i; ++j) {
                if (i % j == 0 && !f[i - j]) {
                    f[i] = true;
                    break;
                }
            }
        }

        return f[N];
    }
};

