// @File   : 753_crackSafe.cpp
// @Source : https://leetcode-cn.com/problems/cracking-the-safe/
// @Title  : 753. 破解保险箱
// @Auther : sun_ds
// @Date   : 2020/9/23

/**  题目描述：
    有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。

    你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。

    举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.

    请返回一个能打开保险箱的最短字符串。

     

    示例1:

    输入: n = 1, k = 2
    输出: "01"
    说明: "10"也可以打开保险箱。
     

    示例2:

    输入: n = 2, k = 2
    输出: "00110"
    说明: "01100", "10011", "11001" 也能打开保险箱。
     

    提示：

    n 的范围是 [1, 4]。
    k 的范围是 [1, 10]。
    k^n 最大可能为 4096。
     



    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/cracking-the-safe
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/**
 *
 * 1. 欧拉图
 * 给了 k 个数字，值为 0 到 k-1，让我们组成 n 位密码。我们可以发现，为了尽可能的使钥匙串变短，所以我们的密码之间尽可能要相互重叠：
 *    - 如果密码是 2 位数，00 和 001 共享一个数 0，可以用来解锁密码为 00 和 01 的两个保险箱
 *    - 如果密码是 3 个数，012 和 0120 共享两个数 12，可以用来解锁密码为 012 和 120 的两个保险箱
 * 我们可以发现，两个长度为 n 的密码最好能共享 n-1 个数字，这样累加出来的钥匙串肯定是最短的。
 * 密码共有 n 位，每一个位可以有 k 个数字，那么总共不同的密码总数就有 k^n 个，而每个密码可以公用 n - 1 位，所以破解保险箱的密码最短长度为：n - 1 + k^n 位。
 *
 *
 * 考虑创建一个有 k^(n-1) 个节点的图，每个节点有 k 条出边，则该图中一共有 k^n 条边
 * 将【节点代表的 n - 1 位数字 + 边代表的 1 位数字】作为经过该条边后尝试的密码值
 * 而经过边后到达的新节点代表的 n - 1 位数字，可以作为下一个密码的前 n - 1 位数字使用
 * 这样可以保证每个密码值不重复，又完全覆盖了 k^n 个密码值。
 *
 *
 * 剩下的问题即是遍历这个欧拉图的所有路径 (一笔画)
 * 类似 332. 重新安排行程
 * 使用 Hierholzer 算法：
 *  1）从起点（以 n - 1 个 0 的节点作为起点，当然也可以选择其他节点）出发，进行深度优先搜索。
 *  2）每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边（标记该条边已经过）。
 *  3）如果没有可移动的路径，则将所在节点加入到字符串中，并返回。     后加入到字符串中。
 *
 *
 * 时间复杂度 O(N*K^N)
 * 空间复杂度 O(N*K^N)
 *
 *
 */

class Solution {
private:
    unordered_set<int> seen;
    string ans;
    int highest;
    int k;

public:
    void dfs(int node) {
        for (int x = 0; x < k; ++x) {
            int nei = node * 10 + x;
            // 去重
            if (!seen.count(nei)) {
                seen.insert(nei);
                dfs(nei % highest);
                // 逆序填充，即第一个填进去的是第一个走投无路的“死胡同”
                ans += (x + '0');
            }
        }
    }

    string crackSafe(int n, int k) {
        highest = pow(10, n - 1);
        this->k = k;
        dfs(0);
        // n 位 k 进制数，可以做到每两个数之间重叠n-1 位，所以n 位 k 进制数最少用 k^n + n-1 位字符表示
        ans += string(n - 1, '0');
        // 全部逆向，反不反转无所谓
        // reverse(ans.begin(), ans.end());
        return ans;
    }
};

