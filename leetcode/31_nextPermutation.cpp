// @File   : 31_nextPermutation.cpp
// @Source : https://leetcode-cn.com/problems/next-permutation/
// @Title  : 下一个排列
// @Auther : sun_ds
// @Date   : 2019/11/21

/**  题目描述：
    实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。

    如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。

    必须原地修改，只允许使用额外常数空间。

    以下是一些例子，输入位于左侧列，其相应输出位于右侧列。
    1,2,3 → 1,3,2
    3,2,1 → 1,2,3
    1,1,5 → 1,5,1

    来源：力扣（LeetCode）
    链接：https://leetcode-cn.com/problems/next-permutation
    著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/** 下一个排列
 * 算法需要将给定数字序列重新排列成字典序中下一个更大的排列
 *
 * n个数字的序列共有A(n,n)中排列方式，即n!种。
 * 最简单的思路是，生成所有序列并排序，找到恰好比当前大一个的排列
 * 复杂度过于高。。。
 *
 * 思路，要想当前序列略微变大，肯定是从低位开始向高位搜索，即从后往前。
 * 由于数字是固定的，只能交换位置，所以，只有找到高位的数字小于低位的数字时才有机会交换变得更大。
 * 因此遍历判断 nums[i] 与 nums[i-1]的大小。
 * 直到找到，满足nums[i] > nums[i-1]时，可以将nums[i-1]与后面数字交换。
 * 通过上述条件的遍历，当前i-1后面的序列自然是反向递增的。
 *
 * 在nums[i-1]与后面数字交换时，为保证略大于当前值，肯定要找到一个略大于nums[i-1]的值，而不是直接交换nums[i-1]和nums[i]
 * 因此从i位置开始，正向遍历，直到找到略多大于nums[i-1]的值，交换。
 *
 * 交换完的序列还是保持反向递增的特征。
 * 为使得结果略大于原有序列，第i-1位的数已经大于原来的了，所以需要使后面的序列尽量的小。
 * 即后面的序列需要正向递减。
 * 所以使用reverse将后面序列反向即可。
 *
 * 得到最终结果即为所要求的结果。
 *
 * 巧妙，严谨~。
 *
 *
 *
 *
 *
 *
 *
 *
 * 思路

    首先想一个问题，什么情况下求下一个排列最简单？根据题意，自然是字典序最大也就是降序排列的时候，因为这种情况的下一个排列就是字典序最小的，将原序列逆序就行了。

    那么我们就围绕这个点来思考。

    对于任意一个序列，我们从后往前找，先找到一个最长递减子序列，比如2 1 7 5 4 3，那么最长递减子序列就是7 5 4 3，把它逆序，变成3 4 5 7，这是最小序列，
    这时整个序列变成了2 1 3 4 5 7。这样还不够，我们还要满足比原序列的字典序大，其实也好处理，最长递减子序列的前一个元素是1，
    我们只需要在最小的序列3 4 5 7中找一个比它大并且最接近它的元素，将它换掉就可以了，显然这个替换的元素是3（替换并没有破坏最小序列的单调性），
    这样整个序列就变成了2 3 1 4 5 7，这也就是我们的目标序列。

    作者：97wgl
    链接：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-on-si-lu-jian-dan-by-97wgl/
    来源：力扣（LeetCode）
    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 *
 *
 */

class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();
        if(n<=1) return;
        int i = n-1;
        while(i>0){
            //从后往前，找到第一个不是按照反向递增的数
            if(nums[i]>nums[i-1]){
                //反向回去，找到略大于自己的值，交换
                //并将交换后的反向递增序列反转，即变成最小子序列
                int j = i;
                while(j<=n-1){
                    if(j==n-1||nums[i-1]>=nums[j+1])
                    {
                        swap(nums[i-1],nums[j]);
                        reverse(nums.begin()+i,nums.end());
                        return;
                    }
                    ++j;
                }
            }
            --i;
        }
        //全部都是反向递增，直接反转所有数
        reverse(nums.begin(),nums.end());
    }
};